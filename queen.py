# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/99queen.ipynb (unless otherwise specified).

__all__ = ['Infinity', 'LOG', 'display', 'diagonals', 'collisions', 'exchange', 'decrease', 'increase', 'evaluate_move',
           'find_move', 'construct', 'fast_tabu_search', 'show_queen']

# Cell
import random
import math
Infinity = 1.0e10000
LOG = False


# Cell
def display(sol):
    """Nicely print the board with queens at positions given in sol"""
    n = len(sol)
    for i in range(0, n):
        for j in range(0, n):
            if sol[i] == j:
                print("o", end=" ")
            else:
                print(".", end=" ")
        print()


def diagonals(sol):
    """Determine number of queens on each diagonal of the board.

    Returns a tuple with the number of queens on each of the upward
    diagonals and downward diagonals, respectively
    """

    n = len(sol)  # size of the board
    ndiag = 2 * n - 1  # number of diagonals in the board

    # upward diagonals (index 0 corresponds to the diagonal on upper-left square)
    diag_up = [0 for i in range(ndiag)]

    # downward diagonals (index 0 corresponds to the diagonal on upper-right square)
    diag_dn = [0 for i in range(ndiag)]

    # count the number of times each diagonal is being attacked
    for i in range(n):
        # upward diagonal being attacked by
        # the queen in row i (which is in column sol[i])
        d = i + sol[i]  # index of diagonal
        diag_up[d] += 1

        # downward diagonal being attacked by
        # the queen in row i (which is in column sol[i])
        d = (n - 1) + sol[i] - i  # index of diagonal
        diag_dn[d] += 1

    return diag_up, diag_dn


def collisions(diag):
    """Returns the total number of collisions on the diagonal."""
    ncolls = 0
    for i in diag:
        if i > 1:  # i.e., more that one queen on this diag
            ncolls += i - 1
    return ncolls


def exchange(i, j, sol, diag_up, diag_dn):
    """Exchange the queen of row i with that of row j; update diagonal info."""

    n = len(sol)

    # diagonals not attacked anymore
    d = i + sol[i]
    diag_up[d] -= 1
    d = j + sol[j]
    diag_up[d] -= 1

    d = (n - 1) - i + sol[i]
    diag_dn[d] -= 1
    d = (n - 1) - j + sol[j]
    diag_dn[d] -= 1

    # exchange the positions 'i' and 'j'
    sol[i], sol[j] = sol[j], sol[i]

    # diagonals that started being attacked
    d = i + sol[i]
    diag_up[d] += 1
    d = j + sol[j]
    diag_up[d] += 1

    d = (n - 1) - i + sol[i]
    diag_dn[d] += 1
    d = (n - 1) - j + sol[j]
    diag_dn[d] += 1


def decrease(di, dj, ni, nj):
    """Compute collisions removed when queens are removed.

    Parameters:
    - di, dj -- diagonals where queens are currently placed
    - ni, nj -- number of queens on these diagonals
    """
    delta = 0
    if ni >= 2:
        delta -= 1
    if nj >= 2:
        delta -= 1
    if di == dj and ni == 2:
        delta += 1  # discounted one in excess, replace it
    return delta


def increase(di, dj, ni, nj):
    """Compute new collisions when queens are positioned.

    Parameters:
    - di, dj -- diagonals where queens will be placed
    - ni, nj -- number of queens on these diagonals
    """
    delta = 0
    if ni >= 1:
        delta += 1
    if nj >= 1:
        delta += 1
    if di == dj and ni == 0:
        delta += 1  # on the same diagonal
    return delta


def evaluate_move(i, j, sol, diag_up, diag_dn):
    """Evaluate exchange of queen of row i with that of row j."""

    delta = 0
    n = len(sol)

    # diagonals not attacked anymore if move is accepted
    upi = i + sol[i]  # current upward diagonal of queen in row i
    upj = j + sol[j]  #                                         j
    delta += decrease(upi, upj, diag_up[upi], diag_up[upj])

    dni = (n - 1) + sol[i] - i  # current downward diagonal of queen in row i
    dnj = (n - 1) + sol[j] - j  #                                           j
    delta += decrease(dni, dnj, diag_dn[dni], diag_dn[dnj])

    # diagonals that started being attacked
    upi = i + sol[j]  # new upward diagonal for queen in row i
    upj = j + sol[i]  #                                      j
    delta += increase(upi, upj, diag_up[upi], diag_up[upj])

    dni = (n - 1) + sol[j] - i  # new downward diagonal of queen in row i
    dnj = (n - 1) + sol[i] - j  #                                       j
    delta += increase(dni, dnj, diag_dn[dni], diag_dn[dnj])

    return delta


def find_move(n_iter, tabu, best_colls, sol, diag_up, diag_dn, ncolls):
    """Return a tuple (i,j) with the best move.

    Checks all possible moves from the current solution, and choose the one that:
         * is not TABU, or
         * is TABU but satisfies the aspiration criterion

    The candidate list is composed of all the possibilities
    of swapping two lines.

    ParameterS:
    """

    n = len(sol)
    best_delta = n  # value of best found move
    for i in range(0, n - 1):
        for j in range(i + 1, n):
            delta = evaluate_move(i, j, sol, diag_up, diag_dn)

            print("move %d-%d" % (i, j), "-> delta=%d;" % delta, end=" ")
            if tabu[i] >= n_iter:
                print("move is tabu;", end=" ")
                if ncolls + delta < best_colls:
                    print("aspiration criterion is satisfied;", end=" ")
            print()

            if (
                tabu[i] < n_iter or ncolls + delta < best_colls  # move is not tabu,
            ):  # or satisfies aspiration criterion
                if delta < best_delta:
                    best_delta = delta
                    best_i = i
                    best_j = j

    return best_i, best_j, best_delta


# Cell
def construct(sol):
    n = len(sol)
    ndiag = 2 * n - 1  # number of diagonals in the board

    # upward diagonals (index 0 corresponds to the diagonal on upper-left square)
    diag_up = [0 for i in range(ndiag)]

    # downward diagonals (index 0 corresponds to the diagonal on upper-right square)
    diag_dn = [0 for i in range(ndiag)]

    cand = list(range(n))
    trials = 10 * int(math.log10(n))  # number of random trials
    for i in range(n):
        for t in range(trials):
            col_id = random.randint(0, len(cand) - 1)
            col = cand[col_id]
            colls = diag_up[i + col] + diag_dn[(n - 1) - i + col]
            if colls == 0:
                sol[i] = col
                diag_up[i + col] += 1
                diag_dn[(n - 1) - i + col] += 1
                del cand[col_id]
                break
        else:
            mincolls = Infinity
            col_id = -1
            for j in range(len(cand)):
                colls = diag_up[i + cand[j]] + diag_dn[(n - 1) - i + cand[j]]
                if colls < mincolls:
                    mincolls = colls
                    col = cand[j]
                    col_id = j
            sol[i] = col
            diag_up[i + col] += 1
            diag_dn[(n - 1) - i + col] += 1
            del cand[col_id]
        # print "row",i,"is assigned to col",col
    return diag_up, diag_dn


def fast_tabu_search(sol, diag_up, diag_dn):
    LOG = 0
    n = len(sol)
    tabu = [-1] * n
    maxiter = 100000
    tabulen = min(10, n)
    for n_iter in range(maxiter):
        for i in range(n - 1, -1, -1):
            colls = diag_up[i + sol[i]] + diag_dn[(n - 1) - i + sol[i]]
            if colls - 2 > 0:
                istar = i
                break
        else:  # no collusion, we finish the search
            break

        # print "swap candidate is",istar
        delta = -999999
        jstar = -1
        for j in range(n):
            if tabu[j] >= n_iter or j == istar:
                continue
            temp = (diag_up[j + sol[j]] + diag_dn[(n - 1) - j + sol[j]] + colls) - (
                diag_up[istar + sol[j]]
                + diag_dn[(n - 1) - istar + sol[j]]
                + diag_up[j + sol[istar]]
                + diag_dn[(n - 1) - j + sol[istar]]
            )
            if temp > delta:
                delta = temp
                jstar = j

        print("iter=", n_iter, "swap", istar, jstar, "delta=", delta)
        if jstar == -1:  # clear tabu list
            tabulen = int(tabulen / 2) + 1
            tabu = [-1] * n
        else:
            tabu[istar] = tabu[jstar] = n_iter + random.randint(1, tabulen)
            exchange(istar, jstar, sol, diag_up, diag_dn)

        if LOG:
            display(sol)
            up, dn = diagonals(sol)
            print("queens on upward diagonals:", up)
            print("queens on downward diagonals:", dn)
            ncolls = collisions(up) + collisions(dn)

# Cell

# export
def show_queen(sol):
    n = len(sol)
    node_size = 500 // n
    node_x = []
    node_y = []
    for i, j in enumerate(sol):
        node_x.append(i)
        node_y.append(j)
    node_trace = go.Scatter(
        x=node_x, y=node_y, mode="markers", marker=dict(size=node_size, line_width=2)
    )
    layout = go.Layout(
        # title='Graph',
        width=1000,
        height=1000,
        titlefont_size=16,
        showlegend=False,
        hovermode="closest",
        # margin=dict(b=20,l=5,r=5,t=40),
        xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
        yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
    )
    fig = go.Figure([node_trace], layout)
    return fig
